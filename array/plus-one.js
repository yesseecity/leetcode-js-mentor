/**
 * LeetCode 題目：Plus One (加一)
 *
 * 題目敘述：
 * 給定一個由整數組成的非空陣列，表示一個非負整數。
 * 陣列中的每個元素代表該整數的一個數字。
 * 最高位數字儲存在陣列的首位，陣列中的每個元素只儲存一個數字。
 * 你可以假設該整數除了數字 0 本身之外，不會以零開頭。
 *
 * 將該整數加一。
 *
 * 範例 1:
 * 輸入: digits = [1,2,3]
 * 輸出: [1,2,4]
 * 解釋: 陣列表示數字 123。
 *
 * 範例 2:
 * 輸入: digits = [4,3,2,1]
 * 輸出: [4,3,2,2]
 * 解釋: 陣列表示數字 4321。
 *
 * 範例 3:
 * 輸入: digits = [0]
 * 輸出: [1]
 *
 * 範例 4:
 * 輸入: digits = [9]
 * 輸出: [1,0]
 */

/**
 * @param {number[]} digits
 * @return {number[]}
 */
const plusOne = (digits) => {
  // 1. 從陣列的最後一個數字開始遍歷。
  //    這是因為我們通常從個位數開始加法運算。
  //    思考如何使用迴圈來實現這個遍歷。

  // 2. 對當前數字加一。
  //    如果加一後結果小於 10，表示沒有進位。
  //    此時，我們可以將這個新數字放回陣列中，並直接返回陣列。
  //    因為後續的數字都不需要改變。

  // 3. 如果加一後結果等於 10，表示有進位。
  //    此時，當前數字應該變為 0。
  //    然後，我們需要繼續處理前一位數字，因為進位會影響到它。
  //    思考如何將當前數字設為 0，並讓迴圈繼續處理前一位。

  // 4. 如果迴圈遍歷完所有數字，並且仍然有進位（例如輸入是 [9,9,9]）。
  //    這表示我們需要一個新的最高位數字 1。
  //    此時，陣列的所有數字都變成了 0。
  //    思考如何在陣列的最前面插入一個 1，並返回新的陣列。
  //    例如，[9,9,9] 加一後會變成 [1,0,0,0]。

  for (let i = digits.length - 1; i >= 0; i--) {
    console.log(digits[i]);
    if (digits[i] < 9) {
      digits[i] += 1;
      return digits;
    } else {
      digits[i] = 0;
    }
    if (i === 0) digits.unshift(1);
  }
  return digits
};

// 測試案例
console.log("測試案例 1:");
console.log("輸入: [1,2,3], 預期輸出: [1,2,4]");
console.log("實際輸出:", plusOne([1, 2, 3])); // 預期輸出: [1,2,4]

console.log("\n測試案例 2:");
console.log("輸入: [4,3,2,1], 預期輸出: [4,3,2,2]");
console.log("實際輸出:", plusOne([4, 3, 2, 1])); // 預期輸出: [4,3,2,2]

console.log("\n測試案例 3:");
console.log("輸入: [0], 預期輸出: [1]");
console.log("實際輸出:", plusOne([0])); // 預期輸出: [1]

console.log("\n測試案例 4:");
console.log("輸入: [9], 預期輸出: [1,0]");
console.log("實際輸出:", plusOne([9])); // 預期輸出: [1,0]

console.log("\n測試案例 5: 處理多位進位");
console.log("輸入: [9,9], 預期輸出: [1,0,0]");
console.log("實際輸出:", plusOne([9, 9])); // 預期輸出: [1,0,0]

console.log("\n測試案例 6: 處理全部進位");
console.log("輸入: [9,9,9], 預期輸出: [1,0,0,0]");
console.log("實際輸出:", plusOne([9, 9, 9])); // 預期輸出: [1,0,0,0]
